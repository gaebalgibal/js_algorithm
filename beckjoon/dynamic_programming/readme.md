# Dynamic Programming (동적 계획법)
: 하나의 큰 문제를 여러 개의 작은 문제로 나눠서 결과를 저장하고 그것을 이용하여 큰 문제를 해결하는 방법

<br>

> **동적 프로그래밍을 적용하기 위해 만족해야하는 조건**
> - 최적 부분 구조(Optimal Substructure): 전체 문제의 최적해가 부분 문제의 최적해로부터 구해질 수 있어야함
> - 중복되는 부분 문제(Overlapping Subproblems): 부분 문제가 중복되어 여러번 반복 계산되어야 함

<br>

### 메모리제이션(Memorization)
: 함수의 실행 결과를 저장하여 이후 같은 입력이 들어올 때 다시 계산하지 않고 저장된 값을 불러와서 재활용하는 최적화 기법 (cache)

<br>

> **메모리제이션을 사용하기 위해 만족해야하는 조건**
> - 문제는 부분 문제로 나눌 수 있어야 함
> - 부분 문제는 중복되어야 함
> - 부분 문제의 해결 결과를 저장하고 재사용할 수 있어야 함

<br>

### 동적 프로그래밍의 구현 방법
#### Top-Down
분할 정복과 비슷한 구조를 가지고 있다. 전체 문제를 작은 부분 문제로 나누고, 그 부분 문제들을 해결하기 위해 **재귀적으로** 동작한다. 중복되는 부분 문제들을 해결하기 위해 메모리제이션(Memorization) 기법을 사용한다 (부분 문제의 결과를 캐시하여 재활용하는 것).
<br>
→ 코드의 가독성이 높아지지만, 많은 스택 메모리를 사용할 수 있으며, 메모리제이션의 처리 오버헤드가 존재할 수 있다.

> **분할 정복** <br>
> 문제를 즉각 해결할 수 있을 때까지 재귀적 방식을 통해 두 개 이상의 하위 문제(Sub-problems)들로 나누고(Divide 과정), 문제를 해결한 다음(Conquer 과정) 그 결과를 바탕으로 다시 전체 문제로 돌아가 합치면서 해결해 나가는 과정 <br>
> ex) Merge 정렬, Quick 정렬, 이진 탐색

#### Bottom-Up
재귀적인 호출 없이, 작은 부분 문제들을 먼저 해결하고, 그 결과를 이용해 전체 문제의 최적해를 구하는 방식이다. 이전에 계산한 결과를 배열 or 리스트 등의 자료구조에 저장하고, 그 결과를 이용해 다음 계산 수행한다.
<br>
Bottom-Up은 **반복문**을 이용하여 구현한다.
<br>
→ 코드의 가독성은 낮아질 수 있지만, 많은 반복문을 이용하기 때문에 스택 메모리를 사용하지 않아 메모리 절약 효과가 있으며, 메모리제이션의 처리 오버헤드가 없다.
